#ifndef __SEVERED_H
#define __SEVERED_H

typedef struct access {
  __u64 gfn;
  u32 error_code;
  ktime_t time;
} access_t;

#include <linux/kvm_targets.h>

#define MAX_SEV_BUF_SIZE 150000
// Used when starting/stopping tracking in order to iterate through all VM
// memory.
// TODO: Determine VM memory size at runtime
#define MAX_VM_MEMORY 0xFFFFF
// Used to check if a pfn is out of bounds
// TODO: Determine host memory size at runtime
#define MAX_HOST_MEMORY 0xFFFFFF

#define SEVERED_NONE 0
#define SEVERED_STARTTR 1
#define SEVERED_STOPTR 2
#define SEVERED_CHGMP 3

// i took a smaller value (text section is acutally larger) because is saw some
// value changes in larger offsets
// TODO: Where the value changes address fixups (in this case keep this value)
// or did they happen after boot due to overlap of vmlizu and vmlinux load
// address
#define VM_MEMORY_IN_MB 1000
#define PAGECOUNT_VMLINUZ 2080ull

// TODO: replace this with constant from autogenerated header
//#define GPA_x86_64_START_KERNEL 0x4e824c0ull
extern spinlock_t kaslr_attack_lock;
extern bool kaslr_attacked;
extern int pf_counter;


typedef struct {
  uint64_t target_value;       // value to create in register
  uint64_t repetition_counter; // counts cpuid calls
  uint32_t prev_eax;           // used to detect if cpuid call belongs to us
  uint32_t prev_prev_eax;      // used to detect if cpuid call belongs to us
  uint32_t type;               // 1 = counter gadget; 2 = stack detect gadget
  uint8_t waiting_for_fault;   // indicates to page fault handler we are looking
                               // for write page faults
  void * stack_page_pre_write; //page fault handler copies suspected stack page, before resuming the fault

  uint64_t tmp_fault_gpa;
  uint64_t fault_gpa; // gets filled with latest write page fault by page fault
                      // handler, if waiting_for_page_fault is set to 1
  uint8_t stack_blocks[32]; // buffer to copy detected stack memory
  uint64_t curr_bit; // Should start at 31. indexing starts at 0.tracks which
                     // bit of target_value we want to create next.

  uint8_t round;
  uint64_t last_gpa; // gpa pointing to last part of the gadget
  struct page *text_page;
  struct page *stack_page;
  void *text_mapping;
  void *stack_mapping;
} load_gadget_t;

typedef struct {
  uint8_t dummy;
} stack_detect_gadget_t;

long kvm_start_tracking(struct kvm_vcpu *vcpu);
long kvm_stop_tracking(struct kvm_vcpu *vcpu);
long kvm_change_mapping(struct kvm_vcpu *vcpu);
long __kvm_start_tracking(struct kvm_vcpu *vcpu, enum kvm_page_track_mode mode);

int read_physical(struct kvm *kvm, u64 gpa, void *buff, u64 size,
                  bool decrypt_at_host);

int write_physical(struct kvm *kvm, u64 gpa, u64 size, const void *buf,
                   bool write_plaintexts);

int map_physical(struct kvm *kvm, u64 gpa, bool decrypt_at_host, void **mapping,
                 struct page **page);

void unmap_physical(void **mapping, struct page **page);
int read_mapped(u64 gpa, void *buff, u64 size, void *mapping);
int write_mapped(u64 gpa, u64 size, const void *buf, void *mapping);

int get_hpa_for_gpa(struct kvm *kvm, gpa_t gpa, hpa_t *hpa);
int print_physical(struct kvm *kvm, u64 gpa, u64 size, bool decrypt_at_host);
bool __track_single_page(struct kvm_vcpu *vcpu, gpa_t gpa,
                         enum kvm_page_track_mode mode);
bool __untrack_single_page(struct kvm_vcpu *vcpu, gfn_t gfn,
                           enum kvm_page_track_mode mode);
bool update_access_rights_unlocked(struct kvm_vcpu *vcpu, gfn_t gfn,
                                   enum kvm_page_track_mode mode);
int kvm_start_tracking_triggers(struct kvm_vcpu *vcpu);
bool sev_handle_choose_random_location(struct kvm_vcpu *vcpu);

bool inject_code(struct kvm *kvm, gpa_t gpa_target, uint8_t *code,
                 uint64_t length, bool insert_at_back);
bool __inject_code(struct kvm *kvm, gpa_t gpa_target, uint8_t *code,
                   uint64_t length, bool insert_at_back, bool flush);
bool simple_inject_code(struct kvm *kvm, inject_param_t *injp);
bool nf_simple_inject_code(struct kvm *kvm, inject_param_t *injp,
                           void *mapping);

bool nf_simple_inject_code_precalc(struct kvm *kvm, inject_param_t *injp,
		void * buffer);
bool nf_buffered_inject(struct kvm *kvm, inject_param_t *injp, void * buffer, void *mapping);
#endif
